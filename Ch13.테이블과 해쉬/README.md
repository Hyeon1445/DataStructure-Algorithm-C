# 테이블

탐색 연산의 시간 복잡도 : O(1)

* 저장되는 데이터는 키(key)와 값(value)이 하나의 쌍을 이룬다.
* 키(key)가 존재하지 않는 값은 저장할 수 없고 모든 키는 중복X

예시 : 우편함, 사전

[단점]

(만약 직원 고유범위의 범위가 100000~999999일 때)

* 직원 고유범위의 범위가 배열의 인덱스 값으로 적당X
* 직원 고유번호의 범위를 수용할 수 있는 매우 큰 배열이 필요!

=>Hash로 해결


# Hash

해쉬 함수 : 넓은 범위의 키를 좁은 범위의 키로 변경하는 역할!

but, 만약 사번이 20170003, 20210003이면 둘다 해쉬함수의 결과값은 003이므로 충돌발생!



# 좋은 해쉬 함수의 조건

* 데이터가 테이블의 전체 영역에 골고루 분포 -> 충돌 발생 확률 낮다!
* 데이터가 특정 영역에 몰렸다 ->충돌 발생 확률 높다!

좋은 해쉬 함수는 키의 일부분이 아닌 키 전체를 참조하여 해쉬 값을 만든다


# 충돌(Collision)의 해결

INUSE, EMPTY, DELETED 세가지로 표기 필요!

DELETED로 표기되었을 경우 해당 칸만 찾는 것이 아니라 다음 칸도 찾아본다

* 선형 조사법
	* 충돌 발생 시 옆자리가 비었는지 보고, 비었으면 그 자리에 저장
	* f(k)+1 , f(k)+2, f(k)+3 ...
	* 단점) 클러스터 현상 : 특정 영역에 데이터 몰림, 충돌 확률 up
	* 열린 어드레싱 방법

* 이차 조사법
	* f(k)+1, f(k)+4, f(k)+9, f(k)+16...
	* 단점) 해쉬 값이 같으면 충돌 시 빈 슬롯을 찾기 위해 접근하는 위치가 늘 같다
	* 열린 어드레싱 방법

* 이중 해쉬 DOUBLE HASH
: 두 개의 해쉬 함수 사용! 클러스터 현상 발생 확률 DOWN!
	* 1차 해쉬 함수 : 키를 근거로 저장위치 결정 h1(k)=k%15 (15는 배열의 길이)
	* 2차 해쉬 함수 : 충돌 발생시 몇 칸 뒤를 살필지 결정 h2=1+(k%c) (c는 15보다 작은 소수중에 결정, +1은 0이 되는 것 방지)
	* 열린 어드레싱 방법	

* 체이닝 
	* 닫힌 어드레싱 방법
	* 충돌이 발생해도 자신의 자리에 들어가겠다!!
	* 배열은 충돌 발생X면 메모리 낭비 심하다!
	* 연결 리스트 이용!!
	* 단점) 탐색 할 때 동일 해쉬 값으로 묶인 연결된 슬롯을 모두 조사해야 한다





