# 그래프

* 수학자 '오일러' 고안
* 쾨니히스베르크의 다리 문제

<br>

* 정점
* 간선

<br>

* 무방향 그래프(undirected graph)
* 방향 그래프(directed graph) ( 다이 그래프 )
* 완전 그래프(complete graph) : 모든 정점에 간선 연결된 상태! (방향 그래프에서는 양쪽 방향으로 모두 연결해서 간선 수가 무방향의 두배!)
* 가중치 그래프(weight graph) : 간선에 가중치 정보 포함 (ex : 두 정점을 이동하는데 걸리는 시간 - 최단시간 길 찾기)
* 부분 그래프(sub graph) : 원래 그래프의 일부 정점, 간선으로 이루어짐

<br><br>

# 그래프의 집합 표현

* 정점(vertex) V(G) 
* 간선(edge) E(G)

V(G1)={A,B,C,D}

E(G1)={(A,B),(A,C),(A,D),(B,C),(C,D)} : 무방향 그래프에서는 (A,B)=(B,A)

E(G2)={<A,B>,<A,C>,<D,A>} : 방향 그래프에서는 <A,B>!=<B,A>


# 그래프 구현

* 인접 행렬(adjacent matrix) : 이차원 배열로 표현 / 무방향 그래프에서는 배열이 대각선 기준으로 대칭 / 방향 그래프는 대칭X
* 인접 리스트(adjacent list)

# 그래프 탐색

* 깊이 우선 탐색 Depth First Search (DFS)
	* 한 사람에게만 연락한다
	* 연락할 사람이 없으면(아직 연락 안받은사람X), 자신에게 연락한 사람에게 이를 알린다
	* 처음 연락을 시작한 사람의 위치에서 연락 끝
* 너비 우선 탐색 Breadth First Search (BFS)
	* 연결된 모든 사람에게 연락한다
	* 마지막 위치인 사람이 연락할 기회를 갖는 채로 끝남

# DFS 구현
* 스택★ : 경로 정보 추적(되돌아오는 상황에서 사용), 해당 정점을 떠날 때 스택에 저장함
* 배열 : 방문 정보 기록

# BFS 구현
*  큐★ : 방문 차례 기록 ( 다음 후보인 정점들 저장해놨다가 방문하면 하나씩 꺼냄)
* 배열 : 방문 정보 기록

# 최소 비용 신장 트리

트리는 그래프의 한 유형

* 사이클(Cycle)을 형성X

* 단순 경로 : 간선 중복 포함X

* 신장 트리 Spanning tree : 사이클을 형성하지 않는 그래프

* 최소 비용 신장 트리 특징
	* 그래프의 모등 정점이 간선에 의해 하나로 연결됨
	* 그래프 내에서 사이클 형성X

* 최소 신장 트리 알고리즘 
	* 크루스칼 Kruskal 알고리즘 : 가중치를 기준으로 간선을 정렬한 후에 최소신장트리(MST)가 될 때까지 간선을 하나씩 선택/삭제해 나감
	* 프림 Prim 알고리즘 : 하나의 정점을 시작으로 최소신장트리(MST)가 도리 때까지 트리를 확장해 나감

# 크루스칼 알고리즘

* 가중치를 기준으로 간선을 정렬한 후에 최소신장트리 MST가 될 때까지 간선을 하나씩 선택/삭제해 나감
  
* 선택해서 간선을 추가해 나가는 경우 ) 만약 그래프 내 사이클이 형성되면 다음 간선 선택
  
* 하나씩 간선을 삭제해 나가는 경우 ) 만약 현재 삭제해야 할 간선을 삭제하면 정점에 연결된 간선이 하나도 남지 않을 때 다음 간선 삭제

* MST최소신장트리의 최종 결과 : 간선 수+1=정점 수
  
* 가중치를 기준으로 정렬할 때 우선순위큐 Priority Queue 사용!
